\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{textcomp}
\usetikzlibrary{patterns}
\usepackage{pdfpages}
\usepackage{gauss}
\usepackage{fancyvrb}
\usepackage[table]{colortbl}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[margin=2.5 cm]{geometry}

\delimitershortfall-1sp
\newcommand\abs[1]{\left|#1\right|}

\definecolor{listinggray}{gray}{0.9}
\usepackage{listings}
\lstset{
	language=,
	literate=
		{æ}{{\ae}}1
		{ø}{{\o}}1
		{å}{{\aa}}1
		{Æ}{{\AE}}1
		{Ø}{{\O}}1
		{Å}{{\AA}}1,
	backgroundcolor=\color{listinggray},
	tabsize=2,
	rulecolor=,
	basicstyle=\scriptsize,
	upquote=true,
	aboveskip={0.2\baselineskip},
	columns=fixed,
	showstringspaces=false,
	extendedchars=true,
	breaklines=true,
	prebreak =\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	frame=single,
	showtabs=false,
	showspaces=false,
	showlines=true,
	showstringspaces=false,
	identifierstyle=\ttfamily,
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941},
  moredelim=**[is][\color{blue}]{@}{@},
}
\newcommand{\comment}[1]{%
  \text{\phantom{(#1)}} \tag{#1}}
\lstdefinestyle{base}{
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
}

\pagestyle{fancy}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}
\newcommand*\squared[1]{%
  \tikz[baseline=(R.base)]\node[draw,rectangle,inner sep=0.5pt](R) {#1};\!}
\cfoot{Page \thepage\ of \pageref{LastPage}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\author{Ola Rønning (vdl761) \\ Tobias Hallundbæk Petersen (xtv657)}
\title{Advanced Computer Systems \\ Assignment 1}
\lhead{Advanced Computer Systems}
\rhead{Assignment 1}

\begin{document}
\maketitle
\section{Fundamental Abstractions}
\begin{enumerate}
  \item Let us assume that at initialization the administrator of the system knows, how much the system might be scaled up, let us call this $S$, thus the total amount of machines ever scaled to will be at most $SK$. We will then have an array of size $SK$, this will hold communication info necessary for read and write to the individual machines. This array along with its information will reside in the api of the user, giving them direct access to the individual machines. Upon scaling up the new machine will broadcast out to all other machines, which will then update the data-structure at the user upon the next read or write request.\\
    In the case that a machine goes down, the given request will time out and the user will be notified of the error. As there is no request for redundancy in the abstraction, this way of handling it is acceptable.
    The only centralized component in the design is the data-structure at the individual user. And as explained before, any changes done in the form of adding or removing machines will be relayed back to the user in the next request.
  \item For the API, we will denote $n = \lceil \lg (SK) \rceil$, \texttt{\&} will denote bitwise AND, \texttt{>>} denotes bit-shift and lastly all addresses and $n$ is considered as unsigned integers.\\
    \begin{lstlisting}[language=Ruby, caption={READ}]
read(addr)
  machine = machines[addr & (n^2 - 1)]
  machine.requestRead(addr >> n)
  case machine.response of
    value:
      return value
    (changes, value):
      machines = changes(machines)
      return value
    time out:
      raise machineTimeoutException
    \end{lstlisting}
    \begin{lstlisting}[language=Ruby, caption={WRITE}]
write(addr, value)
  machine = machines[addr & (n^2 - 1)]
  machine.requestWrite(addr >> n, value)
  case machine.response of
    ok:
      return
    (changes):
      machines = changes(machines)
      return
    time out:
      raise machineTimeoutException
    \end{lstlisting}
  \item
    READ/WRITE operations against regular main memory is atomic, the operations against our memory abstraction is also atomic. We have achieved that by always waiting on a response from the machines, whether or not the operation went through, or if it failed, meaning it timed out.
  \item
    In the case that a machine goes down, the data at the given machine would be missing, thus no mapping strategy without redundancy will not be able to retrieve lost data. The memory locations will thus be unavailable, which is what a user could expect from our system, getting an error as opposed to getting the wrong answer is preferable. A new server added that might fill that gap created by a crashing machine, would then be broadcast out in the next request, and the user would be able to address the space again.
\end{enumerate}
\section{Techniques for Performance}
\begin{enumerate}
\item 
\item 
\item 
\end{enumerate}
\section{Discussion for Architecture}
\end{document}
