\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{textcomp}
\usetikzlibrary{patterns}
\usepackage{pdfpages}
\usepackage{gauss}
\usepackage{fancyvrb}
\usepackage[table]{colortbl}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[margin=2.5 cm]{geometry}

\delimitershortfall-1sp
\newcommand\abs[1]{\left|#1\right|}

\definecolor{listinggray}{gray}{0.9}
\usepackage{listings}
\lstset{
	language=,
	literate=
		{æ}{{\ae}}1
		{ø}{{\o}}1
		{å}{{\aa}}1
		{Æ}{{\AE}}1
		{Ø}{{\O}}1
		{Å}{{\AA}}1,
	backgroundcolor=\color{listinggray},
	tabsize=2,
	rulecolor=,
	basicstyle=\scriptsize,
	upquote=true,
	aboveskip={0.2\baselineskip},
	columns=fixed,
	showstringspaces=false,
	extendedchars=true,
	breaklines=true,
	prebreak =\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	frame=single,
	showtabs=false,
	showspaces=false,
	showlines=true,
	showstringspaces=false,
	identifierstyle=\ttfamily,
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941},
  moredelim=**[is][\color{blue}]{@}{@},
}
\newcommand{\comment}[1]{%
  \text{\phantom{(#1)}} \tag{#1}}
\lstdefinestyle{base}{
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
}

\pagestyle{fancy}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}
\newcommand*\squared[1]{%
  \tikz[baseline=(R.base)]\node[draw,rectangle,inner sep=0.5pt](R) {#1};\!}
\cfoot{Page \thepage\ of \pageref{LastPage}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\author{Ola Rønning (vdl761) \\ Tobias Hallundbæk Petersen (xtv657)}
\title{Advanced Computer Systems \\ Assignment 1}
\lhead{Advanced Computer Systems}
\rhead{Assignment 1}

\begin{document}
\maketitle
\section{Fundamental Abstractions}
\begin{enumerate}
  \item Let us assume that at initialization the administrator of the system knows, how much the system might be scaled up, let us call this $S$, thus the total amount of machines ever scaled to will be at most $SK$. We will then have an array of size $SK$, this will hold communication info necessary for read and write to the individual machines. This array along with its information will reside in the api of the user, giving them direct access to the individual machines. Upon scaling up the new machine will broadcast out to all other machines, which will then update the data-structure at the user upon the next read or write request.\\
    In the case that a machine goes down, the given request will time out and the user will be notified of the error. As there is no request for redundancy in the abstraction, this way of handling it is acceptable.
    The only centralized component in the design is the data-structure at the individual user. And as explained before, any changes done in the form of adding or removing machines will be relayed back to the user in the next request.
  \item For the API, we will denote $n = \lceil \lg (SK) \rceil$, \texttt{\&} will denote bitwise AND, \texttt{>>} denotes bit-shift and lastly all addresses and $n$ is considered as unsigned integers.\\
    The read will address find the machines by masking the $n$ first bits of the given address, the object at this array will expose a function \texttt{requestRead(int)} that will send the request and \texttt{response} which will loop until a response is given or timeout is reached. The response can hold a function that needs to be applied to the current array of machines.
    \begin{lstlisting}[language=Ruby, caption={READ}]
read(addr)
  machine = machines[addr & (n^2 - 1)]
  machine.requestRead(addr >> n)
  case machine.response of
    value:
      return value
    (changes, value):
      machines = changes(machines)
      return value
    time out:
      raise machineTimeoutException
    \end{lstlisting}
    The write is more or less the same as the read, only differing in the added functionality that the user supplies the value to be written.
    \begin{lstlisting}[language=Ruby, caption={WRITE}]
write(addr, value)
  machine = machines[addr & (n^2 - 1)]
  machine.requestWrite(addr >> n, value)
  case machine.response of
    ok:
      return
    (changes):
      machines = changes(machines)
      return
    time out:
      raise machineTimeoutException
    \end{lstlisting}
  \item
    READ/WRITE operations against regular main memory is atomic, the operations against our memory abstraction is also atomic. We have achieved that by always waiting on a response from the machines, whether or not the operation went through, or if it failed, meaning it timed out.
  \item
    In the case that a machine goes down, the data at the given machine would be missing, thus no mapping strategy without redundancy will not be able to retrieve lost data. The memory locations will thus be unavailable, which is what a user could expect from our system, getting an error as opposed to getting the wrong answer is preferable. A new server added that might fill that gap created by a crashing machine, would then be broadcast out in the next request, and the user would be able to address the space again.
\end{enumerate}
\section{Techniques for Performance}
\begin{enumerate}

\item Utilizing concurrency will not influence the latency of unit task a computer system performs, where a unit task is task that has no dependencies on other task the system performs. However, for system tasks that perform several concurrent unit tasks as subtask will have its latency reduced by as some of these will be performed simultaneously. The latency reduction only holds when the overhead of performing unit tasks concurrently is smaller than the gain from concurrent execution.
\item \paragraph{Dallying} is when a system tasks wait with performing a subtask either to batch the request together with later requests or to completely avoid performing the request. An example of dallying is lazy evalutation of programs, where evalutation of expression are deffered until their needed by other computations.
\paragraph{Batching} is when a system task performs a subtask on a group on of requests intead of a single request. Batching is often deployed as an optimization for expensive subtasks such as communicating over a network or lookups in an enormous table. An example of batching is when acknowledgements are piggybacked in TCP.
\item Chaching is an example of fast-path optimization. Cahching makes retriaval time of previously processed request faster by storing their results, thereby creating a fast path for cached results.
\end{enumerate}
\section{Discussion for Architecture}
\subsection{Implementation and testing describtion}
\paragraph{Testing} is performed on the implemeneted buisness logic both as local calls (LC) and remote procedure calls (RPC), only by changing the setup of the testing class. This is reflected in code where the implementation of the unite test are in the abstract class, \texttt{BookStoreTest}, which is extended by the \texttt{HTTPTest} class and the \texttt{LocalTest} class which perform the before mentioned setup to handle LC or RPC respictively. For RPC the implementation spawns a new java thread that runs the server before the class is construcnted, and then sends a stop to the server as part of the tear down of the class. All the implemented tests check that the state of the bookstore after a mutation is performed is consistent with how the bookstore looked before the mutation.
We have implemented the following test to demostrate correctness of the implemented \textit{rateBooks} method:
\begin{itemize}
\item \textit{testRateNoneExistingISBN} test that only books that are in the store can be rated. Rating a book not present in the bookstore throws an error message and the after state should therefore be the same as the before state, as none of the rating should be committed.
\item \textit{testRateNonsenseISBN} test that only valid ISBN can be used to rate books, in the implementation of \texttt{rateBooks} this check is performed to before checking whether the book is present in the bookstore. For the same reasoning as with \texttt{testRateNoneExistingISBN} testing method the state of the bookstore should not change after attempting to rate a nonsense isbn.
\item \textit{testGiveInvalidRating} test that only valid ratings can be given, that is ratings between one and five inclusiive. The bookstores state should not change if an invalid rating is given.
\item \textit{testGiveValidRating} test that given valid ratings of books in the store the rating of the book is aggregated. To perform this test a mutable book is added to the bookstore, this book is then rated and checked that the rating of this book is upadted expected. Finally we remove the book from the bookstore and check that nothing else has changed.
\end{itemize}
\paragraph{Implemntation}
\end{document}
